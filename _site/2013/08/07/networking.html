<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Networking in Radiodan</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body id="post">
        <a href="https://github.com/radiodan">
          <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub">
        </a>
        <div class="container masthead">
            <div class="site">
                <div class="header">
                  <h1 class="title"><a href="/">Radiodan</a></h1>
                  <a class="extra" href="/#about">about</a>
                  <a class="extra" href="/#blog">blog</a>

                  <a href="https://twitter.com/teamradiodan" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @teamradiodan</a>
                  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
                </div>
                <div class="hero">
                  An (experimental) homebrew, flexible, open source, IP radio
                </div>
            </div>
        </div>

        <div class="container">
          <div class="site">
                <h2>Networking in Radiodan</h2>
<p class="meta">07 Aug 2013 by <a href="http://github.com/libbymiller">libbymiller</a></p>

<div class="post">
<p>There are two current areas of practical research in radiodan. The first has to do with one of the biggest 
bugbears of working with networked devices, particularly ones with no screen: getting it on the network and 
talking to it. The second is about installation and interaction: choosing the level of flexibility. This post is 
about the work on networking. I&#39;ll write up the rest soon.</p>

<h2>The problem with setup/connecting to wifi</h2>

<p>For Raspberry Pis in general, people use them either with a screen and keyboard, getting networking information 
using the screen, or else headlessly, i.e. without a screen. This is where the problem comes. Moving the devices 
between networks means that you need to get them on the network to talk to them and for them to talk to the 
outside world, without being able to see the usual information on a screen.</p>

<p>So for example, BBC Salford has a lovely Darlek robot made using a Raspberry Pi, which can be controlled remotely via a 
series of RESTful commands (move forward, speak etc). It has its home network programmed into it 
(probably using <a href="https://wiki.archlinux.org/index.php/WPA_supplicant">wpa supplicant</a>, a linux networking tool that allows you to plug in and use wifi devices and 
specific which networks with passwords that they should attempt to connect to in a textfile.)</p>

<p><img src="/assets/darlek.jpg" width="500" alt="Knitted Darlek"/></p>

<p>Move it off a network it knows about and you have to do one of two things in order to connect it up:</p>

<ul>
<li>connect the Pi to a screen via its HDMI port and use a keyboard to enter the network information</li>
<li>connect it up to your own computer via an ethernet connection and share your network with it and then connect to 
it over ssh to use wpa supplicant or similar to get it on a network</li>
</ul>

<p>The first of these may not be very convenient, because smallish HDMI screens may not be available. Modern TVs 
usually have HDMI sockets, but not all monitors do, and in any case you don&#39;t necessarily want to carry one around 
with you. The second approach is feasible with Mac OS X (though not when the wifi network is 
certificate-protected).</p>

<p>Once you have managed to tell the device how to get on to a network, you then may need to connect to it the next 
time you want to talk to it. For a developer working on a Pi, typically you&#39;ll want to try something out and reboot it. </p>

<p>If you are sharing your network with it, you can do this again, either finding the IP address via the console or 
nmap and sshing to it that way, or by installing Avahi on it and thereby giving it a known name so you can connect 
to it on the same network (e.g. &#39;radiodan.local&#39;). (Typically anything giving out IP addresses using DHCP will 
tend to give out the same one to the same device, but you can&#39;t rely on that).</p>

<p>If you have not installed Avahi on it, or if you are on a different network, you will need to find its IP address 
somehow. Again, you will need to either connect it up to a monitor and keyboard to see its IP (&#39;ifconfig&#39;), or use 
nmap or Mac OS X console if you&#39;re on the same network / sharing; or use some sort of display connected to the 
GPIO. Or you could make it say its IP address using espeak, which is easy to do but is often hard to hear and 
remember.</p>

<h2>Reconnecting and developing</h2>

<p>In the development of Radiodan we always have half an eye on ease of use for future developers. We want to make it 
easy for others who don&#39;t have huge amounts of time or great skills in networking on linux-like systems to get 
started. None of the current solutions is very easy. It&#39;s a substantial hurdle to getting things working for 
people.</p>

<p>Developers have two distinct problems:</p>

<ul>
<li>telling the device about the network</li>
<li>talking to the device on the network</li>
</ul>

<p>The two problems have parallels in the consumer area too. Printers, networked web cameras and other consumer 
devices have this problem: they need to get on the network (perhaps with no easy user input device or feedback 
device) and other devices need to talk to them once they are on there. It&#39;s obviously something that many 
Raspberry Pi and Arduino developers have thought about. There are also other newer devices like the Imp that try 
to solve this problem (and we&#39;ll talk about those in another post).</p>

<h2>Our solution</h2>

<p>For now and to solve our immediate problem, we&#39;ve taken a similar approach to <a href="http://blog.arduino.cc/2013/05/18/welcome-arduino-yun-the-first-member-of-a-series-of-wifi-products-combining-arduino-with-linux/">the Arduino 
YÃºn</a>. 
If the Radiodan doesn&#39;t find a wifi network it knows about, it broadcasts its own wifi network with a known name 
and uses Avahi to enable the developer to connect to it at a known identifier via ssh. The developer can then ssh in and 
add wifi networks using wpa supplicant. In the future we plan to make it more easily configurable over a web 
interface, but for now, this greatly simplifies the issues we&#39;ve been having connecting to it on various networks.</p>

</div>

            <div class="footer">
            </div>
          </div>
        </div> <!-- /container -->

        <!-- Anlytics -->
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-19303444-8', 'radiodan.github.io');
          ga('send', 'pageview');
        </script>
    </body>
</html>
